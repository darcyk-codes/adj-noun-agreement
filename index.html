<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- iOS app name -->
<meta name="apple-mobile-web-app-title" content="Possessive Match">

<!-- 180√ó180 icon is the iOS sweet spot -->
<link rel="apple-touch-icon" href="icons/icon-180.png">

<title>Possessive Match ‚Äî Slovene (m/f/n)</title>

<!-- PWA basics -->
<link rel="manifest" href="manifest.webmanifest" />
<meta name="theme-color" content="#0f1115" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="apple-touch-icon" href="icons/icon-192.png" />
<link rel="icon" href="icons/icon-192.png" />

<style>
  :root{
    --pad:14px; --radius:14px;
    --bg:#0f1115; --card:#171a21; --ink:#e9edf1; --muted:#9aa4b2; --accent:#7aa2ff;
    --m:#4db3ff; --f:#ff6fa6; --n:#b499ff; --sg:#31e1a1; --pl:#ffcf33;
    --itemH:44px;
    --warn:#ffd24d; --warn-ink:#1b1400;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 70% -10%,#1d2333,#0f1115);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .app{max-width:1100px;margin:0 auto;padding:18px;display:grid;gap:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  header h1{font-size:20px;margin:0;letter-spacing:.3px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .btn{background:#212634;color:var(--ink);border:1px solid #2a3040;border-radius:10px;padding:10px 12px;cursor:pointer;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:var(--accent);border-color:#6b8df0;color:#081024}
  .btn.ghost{background:transparent;border-color:#2a3040;color:#2f89ff}
  .layout{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .panel{background:var(--card);border:1px solid #23293a;border-radius:var(--radius);padding:var(--pad)}
  .sectionTitle{color:var(--muted);font-size:12px;margin-bottom:8px;letter-spacing:.4px;text-transform:uppercase}

  /* Reels */
  .reel{position:relative;height:240px;overflow:hidden;border-radius:12px;
    background:linear-gradient(#1c2231,#161b27);border:1px solid #23293a;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.02);isolation:isolate;outline:none}
  .reel:focus{box-shadow:0 0 0 2px rgba(122,162,255,.35) inset}
  .reelTrack{position:absolute;width:100%;transition:transform 220ms cubic-bezier(.19,1,.22,1)}
  .reelItem{box-sizing:border-box;display:flex;align-items:center;justify-content:center;height:var(--itemH);
    font-weight:800;letter-spacing:.2px;font-size:18px;opacity:.85;transition:opacity .12s,background-color .12s,color .12s,font-size .12s;user-select:none}
  .reelItem.selected{background:#2a9cf5;color:#0b1220;opacity:1;font-size:30px}

  .reelFooter{display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:8px;flex-wrap:wrap}
  .badgeRow{display:flex;align-items:flex-start;gap:10px;min-height:32px}
  .badge{font-size:12px;color:var(--muted)}

  /* Hint chips */
  .keys{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .keys.hidden{display:none}
  .keyline{display:flex;gap:6px;align-items:center}
  .keychip{display:inline-flex;align-items:center;justify-content:center;height:22px;padding:0 10px;border-radius:999px;font-size:12px;font-weight:800;color:#0a0d14}
  .keychip.m{background:var(--m)} .keychip.f{background:var(--f)} .keychip.n{background:var(--n)}
  .keychip.sg{background:var(--sg)} .keychip.pl{background:var(--pl)}

  .grid{display:grid;gap:12px}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .card{border-radius:12px;padding:14px;background:linear-gradient(180deg,#1b2130,#151a26);border:1px solid #23293a}
  .big{font-size:24px;font-weight:800;letter-spacing:.3px}
  .muted{color:var(--muted);font-size:13px}

  .fileRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type="file"]{display:none}

  .note{color:var(--muted);font-size:12px;line-height:1.4}
  .utf8-note{margin-top:6px;font-size:12px;color:#ffdca8}
  .warn{margin-top:10px;background:var(--warn);color:var(--warn-ink);border-radius:10px;border:1px solid #e6b300;padding:10px 12px;font-size:13px;display:none}
  .warn.show{display:block}
  .meta{font-size:12px;color:var(--muted)}
  @media (max-width:1000px){.layout{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>üé∞ Possessive Match ‚Äî Slovene (m/f/n)</h1>
    <div class="controls">
      <button class="btn" id="newPromptBtn">New Prompt</button>
      <button class="btn" id="toggleHints">Show Hints: ON</button>
      <button class="btn primary" id="checkBtn">Check</button>
    </div>
  </header>

  <!-- Prompt + Feedback -->
  <div class="panel">
    <div class="two">
      <div class="grid">
        <div class="sectionTitle">English Prompt</div>
        <div class="card">
          <div class="big" id="promptText">Tap ‚ÄúNew Prompt‚Äù</div>
          <div class="muted" id="promptHint"></div>
        </div>
      </div>
      <div class="grid">
        <div class="sectionTitle">Feedback</div>
        <div class="card">
          <div class="big" id="resultLine">‚Äî</div>
          <div class="muted" id="explain">Spin both reels to match the prompt, then press ‚ÄúCheck‚Äù.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Reels -->
  <div class="layout">
    <!-- Adjective reel -->
    <div class="panel">
      <div class="sectionTitle">Possessive Adjective (Slovene)</div>
      <div class="reel" id="adjReel" tabindex="0" role="listbox" aria-label="Adjective reel"><div class="reelTrack" id="adjTrack"></div></div>
      <div class="reelFooter">
        <div class="badgeRow">
          <span class="badge" id="adjBadge">Selected: ‚Äî</span>
          <div class="keys" id="adjKeys"></div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn ghost" id="adjPrev">‚óÄ</button>
          <button class="btn ghost" id="adjNext">‚ñ∂</button>
        </div>
      </div>
    </div>

    <!-- Noun reel -->
    <div class="panel">
      <div class="sectionTitle">Noun (from your CSV)</div>
      <div class="reel" id="nounReel" tabindex="0" role="listbox" aria-label="Noun reel"><div class="reelTrack" id="nounTrack"></div></div>
      <div class="reelFooter">
        <div class="badgeRow">
          <span class="badge" id="nounBadge">Selected: ‚Äî</span>
          <div class="keys" id="nounKeys"></div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn ghost" id="nounPrev">‚óÄ</button>
          <button class="btn ghost" id="nounNext">‚ñ∂</button>
        </div>
      </div>
      <div class="fileRow" style="margin-top:10px">
        <input type="file" id="fileInput" accept=".csv" />
        <label for="fileInput" class="btn">Upload Nouns (CSV)</label>
        <span class="badge" id="fileName"></span>
        <span class="meta" id="encodingLabel"></span>
      </div>
      <div class="utf8-note">‚ö†Ô∏è Save your CSV as <strong>CSV UTF-8 (Comma delimited)</strong> to preserve Slovene characters like <strong>ƒç, ≈°, ≈æ</strong>.</div>
      <div class="warn" id="csvWarn">
        ‚ö†Ô∏è It looks like some Slovene characters (ƒç, ≈°, ≈æ) didn‚Äôt import correctly. Please re-export your file as <strong>CSV UTF-8</strong> and upload again.
      </div>
      <div class="note" style="margin-top:8px">
        CSV header required: <code>noun,gender,number,english</code> ¬∑ gender: <code>m|f|n</code> ¬∑ number: <code>sg|pl</code><br/>
        Examples: <code>hi≈°a,f,sg,house</code> ¬∑ <code>maƒçki,m,pl,kittens</code> ¬∑ <code>mesto,n,sg,city</code>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Base adjective forms (flat) ---------- */
const ADJECTIVES_RAW = [
  { form:"moj",   gender:"m", number:"sg", owner:"my" },
  { form:"moja",  gender:"f", number:"sg", owner:"my" },
  { form:"moje",  gender:"n", number:"sg", owner:"my" },
  { form:"moji",  gender:"m", number:"pl", owner:"my" },
  { form:"moje",  gender:"f", number:"pl", owner:"my" },
  { form:"moja",  gender:"n", number:"pl", owner:"my" },

  { form:"tvoj",   gender:"m", number:"sg", owner:"your" },
  { form:"tvoja",  gender:"f", number:"sg", owner:"your" },
  { form:"tvoje",  gender:"n", number:"sg", owner:"your" },
  { form:"tvoji",  gender:"m", number:"pl", owner:"your" },
  { form:"tvoje",  gender:"f", number:"pl", owner:"your" },
  { form:"tvoja",  gender:"n", number:"pl", owner:"your" },

  { form:"njegov",   gender:"m", number:"sg", owner:"his" },
  { form:"njegova",  gender:"f", number:"sg", owner:"his" },
  { form:"njegovo",  gender:"n", number:"sg", owner:"his" },
  { form:"njegovi",  gender:"m", number:"pl", owner:"his" },
  { form:"njegove",  gender:"f", number:"pl", owner:"his" },
  { form:"njegova",  gender:"n", number:"pl", owner:"his" },

  { form:"njen",   gender:"m", number:"sg", owner:"her" },
  { form:"njena",  gender:"f", number:"sg", owner:"her" },
  { form:"njeno",  gender:"n", number:"sg", owner:"her" },
  { form:"njeni",  gender:"m", number:"pl", owner:"her" },
  { form:"njene",  gender:"f", number:"pl", owner:"her" },
  { form:"njena",  gender:"n", number:"pl", owner:"her" },

  { form:"na≈°",   gender:"m", number:"sg", owner:"our" },
  { form:"na≈°a",  gender:"f", number:"sg", owner:"our" },
  { form:"na≈°e",  gender:"n", number:"sg", owner:"our" },
  { form:"na≈°i",  gender:"m", number:"pl", owner:"our" },
  { form:"na≈°e",  gender:"f", number:"pl", owner:"our" },
  { form:"na≈°a",  gender:"n", number:"pl", owner:"our" },

  { form:"va≈°",   gender:"m", number:"sg", owner:"your-pl" },
  { form:"va≈°a",  gender:"f", number:"sg", owner:"your-pl" },
  { form:"va≈°e",  gender:"n", number:"sg", owner:"your-pl" },
  { form:"va≈°i",  gender:"m", number:"pl", owner:"your-pl" },
  { form:"va≈°e",  gender:"f", number:"pl", owner:"your-pl" },
  { form:"va≈°a",  gender:"n", number:"pl", owner:"your-pl" },

  { form:"njihov",   gender:"m", number:"sg", owner:"their" },
  { form:"njihova",  gender:"f", number:"sg", owner:"their" },
  { form:"njihovo",  gender:"n", number:"sg", owner:"their" },
  { form:"njihovi",  gender:"m", number:"pl", owner:"their" },
  { form:"njihove",  gender:"f", number:"pl", owner:"their" },
  { form:"njihova",  gender:"n", number:"pl", owner:"their" },
];

/* ---------- Deduplicate adjectives by (form, owner) ---------- */
function groupAdjectives(rows){
  const map = new Map();
  for(const r of rows){
    const key = `${r.form}||${r.owner}`;
    if(!map.has(key)) map.set(key, { form:r.form, owner:r.owner, variants:[] });
    map.get(key).variants.push({ gender:r.gender, number:r.number });
  }
  const gOrder = {m:0,f:1,n:2};
  const nOrder = {sg:0,pl:1,du:2};
  const out = Array.from(map.values()).map(x=>{
    const seen = new Set();
    x.variants = x.variants
      .filter(v=>{ const k=`${v.gender}|${v.number}`; if(seen.has(k)) return false; seen.add(k); return true; })
      .sort((a,b)=> (gOrder[a.gender]-gOrder[b.gender]) || (nOrder[a.number]-nOrder[b.number]));
    return x;
  });
  return out;
}

/* ---------- Starter nouns (flat) ---------- */
const NOUNS_START = [
  { noun:"hi≈°a",  gender:"f", number:"sg", english:"house" },
  { noun:"mesto", gender:"n", number:"sg", english:"city" },
  { noun:"maƒçek", gender:"m", number:"sg", english:"kitten" },
  { noun:"maƒçki", gender:"m", number:"pl", english:"kittens" },
  { noun:"sestre",gender:"f", number:"pl", english:"sisters" },
];

/* ---------- Group nouns by spelling; require consistent English ---------- */
function groupNouns(rows){
  const map = new Map();
  const conflicts = [];
  const gOrder = {m:0,f:1,n:2};
  const nOrder = {sg:0,pl:1,du:2};

  for(const r of rows){
    if(!r || !r.noun) continue;
    const key = r.noun.normalize('NFC');
    if(!map.has(key)){
      map.set(key, { noun:key, english:r.english, variants:[{gender:r.gender, number:r.number}] });
    } else {
      const entry = map.get(key);
      if (entry.english !== r.english){
        conflicts.push({ noun:key, first:entry.english, other:r.english });
      }
      entry.variants.push({ gender:r.gender, number:r.number });
    }
  }
  // dedupe/sort variants
  const groups = Array.from(map.values()).map(x=>{
    const seen = new Set();
    x.variants = x.variants
      .filter(v=>{ const k=`${v.gender}|${v.number}`; if(seen.has(k)) return false; seen.add(k); return true; })
      .sort((a,b)=> (gOrder[a.gender]-gOrder[b.gender]) || (nOrder[a.number]-nOrder[b.number]));
    return x;
  });

  if (conflicts.length){
    const msg = conflicts
      .slice(0,6)
      .map(c=>`‚Ä¢ ‚Äú${c.noun}‚Äù: using "${c.first}", ignoring "${c.other}"`)
      .join('\n');
    alert('Some nouns had conflicting English glosses. Using the first value found.\n' + msg + (conflicts.length>6?'\n‚Ä¶':''));
  }
  return groups;
}

/* ---------- State ---------- */
let showHints = true;             // single toggle controls chips & feedback detail

let ADJ_GROUPS = shuffle(groupAdjectives(ADJECTIVES_RAW)); // randomized order
let NOUN_GROUPS = groupNouns(NOUNS_START);
let adjLen = ADJ_GROUPS.length;
let nounLen = NOUN_GROUPS.length;
let adjPos = 2*adjLen + 0;  // absolute position inside 5x list
let nounPos = 2*nounLen + 0;

/* ---------- DOM ---------- */
const adjReel = document.getElementById('adjReel');
const nounReel = document.getElementById('nounReel');
const adjTrack = document.getElementById('adjTrack');
const nounTrack = document.getElementById('nounTrack');
const adjBadge = document.getElementById('adjBadge');
const nounBadge = document.getElementById('nounBadge');
const adjKeys = document.getElementById('adjKeys');
const nounKeys = document.getElementById('nounKeys');
const btnShowHints = document.getElementById('toggleHints');
const promptText = document.getElementById('promptText');
const resultLine = document.getElementById('resultLine');
const explain = document.getElementById('explain');
const fileNameEl = document.getElementById('fileName');
const encodingLabel = document.getElementById('encodingLabel');
const csvWarn = document.getElementById('csvWarn');

const buttons = {
  newPromptBtn: document.getElementById('newPromptBtn'),
  checkBtn: document.getElementById('checkBtn'),
  adjPrev: document.getElementById('adjPrev'),
  adjNext: document.getElementById('adjNext'),
  nounPrev: document.getElementById('nounPrev'),
  nounNext: document.getElementById('nounNext'),
  fileInput: document.getElementById('fileInput'),
};

/* ---------- Utils ---------- */
function shuffle(arr){ const a = arr.slice(); for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]] = [a[j],a[i]]; } return a; }
function mod(n,m){ return ((n % m) + m) % m; }

function centerOffsetFor(trackEl){
  const ITEM_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--itemH')) || 44;
  const reelEl = trackEl.parentElement; const reelH = reelEl.clientHeight || 240;
  return { ITEM_H, centerOffset: (reelH/2 - ITEM_H/2) };
}
function buildReel(trackEl, items, renderFn){
  const repeated=[];
  for (let r=0;r<5;r++){
    for (let i=0;i<items.length;i++){
      repeated.push(`<div class="reelItem">${renderFn(items[i])}</div>`);
    }
  }
  trackEl.innerHTML = repeated.join('');
}
function renderByPos(trackEl, len, pos){
  const { ITEM_H, centerOffset } = centerOffsetFor(trackEl);
  const y = -(pos*ITEM_H - centerOffset); trackEl.style.transform=`translateY(${y}px)`;
  const items = trackEl.querySelectorAll('.reelItem'); items.forEach(el=>el.classList.remove('selected'));
  const selectedEl = items[pos]; if (selectedEl) selectedEl.classList.add('selected');
  if (pos < 1*len || pos > 4*len){
    const newPos = 2*len + mod(pos, len);
    const prev = trackEl.style.transition; trackEl.style.transition='none';
    const y2 = -(newPos*ITEM_H - centerOffset); trackEl.style.transform=`translateY(${y2}px)`; trackEl.offsetHeight; trackEl.style.transition = prev; return newPos;
  }
  return pos;
}
function stepAdj(delta){ adjPos = renderByPos(adjTrack, adjLen, adjPos + (delta>0?1:-1)); updateBadges(); }
function stepNoun(delta){ nounPos = renderByPos(nounTrack, nounLen, nounPos + (delta>0?1:-1)); updateBadges(); }

/* Wheel, touch, keyboard handlers */
function wheelHandlerFactory(kind){
  let acc = 0, ticking = false;
  return function(e){
    e.preventDefault(); acc += e.deltaY;
    if (ticking) return; ticking = true;
    setTimeout(()=>{ if (acc > 6) (kind==='adj'?stepAdj(+1):stepNoun(+1));
                     else if (acc < -6) (kind==='adj'?stepAdj(-1):stepNoun(-1));
                     acc = 0; ticking = false; }, 50);
  }
}
function touchHandlerFactory(kind){
  let startY=null;
  return {
    start(e){ startY = e.touches[0].clientY; },
    move(e){
      if(startY==null) return;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dy) > 18){ (kind==='adj'?stepAdj(dy<0?+1:-1):stepNoun(dy<0?+1:-1)); startY = e.touches[0].clientY; }
      e.preventDefault();
    },
    end(){ startY=null; }
  }
}
function keyHandlerFactory(kind){
  return function(e){
    if (['ArrowDown','ArrowRight','ArrowUp','ArrowLeft',' '].includes(e.key)){
      e.preventDefault();
      if (e.key==='ArrowDown' || e.key==='ArrowRight' || e.key===' ') (kind==='adj'?stepAdj(+1):stepNoun(+1));
      if (e.key==='ArrowUp'   || e.key==='ArrowLeft')                 (kind==='adj'?stepAdj(-1):stepNoun(-1));
    }
  }
}

/* ---------- Chips rendering ---------- */
function chip(cls){ const d=document.createElement('div'); d.className=`keychip ${cls}`; d.textContent=cls.toUpperCase(); return d; }
function renderAdjVariants(container, variants){
  container.innerHTML='';
  if(!showHints){ container.classList.add('hidden'); return; }
  container.classList.remove('hidden');
  for(const v of variants){
    const line = document.createElement('div'); line.className='keyline';
    line.appendChild(chip(v.gender)); line.appendChild(chip(v.number));
    container.appendChild(line);
  }
}
function renderNounVariants(container, variants){
  container.innerHTML='';
  if(!showHints){ container.classList.add('hidden'); return; }
  container.classList.remove('hidden');
  for(const v of variants){
    const line = document.createElement('div'); line.className='keyline';
    line.appendChild(chip(v.gender)); line.appendChild(chip(v.number));
    container.appendChild(line);
  }
}

/* ---------- Current selections ---------- */
function currentAdj(){ return ADJ_GROUPS[mod(adjPos, adjLen)]; }
function currentNoun(){ return NOUN_GROUPS[mod(nounPos, nounLen)]; }

function updateBadges(){
  const a=currentAdj(), n=currentNoun();
  adjBadge.textContent = a ? `Selected: ${a.form}` : 'Selected: ‚Äî';
  nounBadge.textContent = n ? `Selected: ${n.noun}` : 'Selected: ‚Äî';
  if (a) renderAdjVariants(adjKeys, a.variants); else adjKeys.innerHTML='';
  if (n) renderNounVariants(nounKeys, n.variants); else nounKeys.innerHTML='';
  btnShowHints.textContent = `Show Hints: ${showHints?'ON':'OFF'}`;
}

/* ---------- Prompt & feedback helpers ---------- */
function ownerLabel(owner){ return owner === 'your-pl' ? 'YOU ALL' : String(owner).toUpperCase(); }
function featAbbrev(g, n){ return `${g}/${n}`.toLowerCase(); }

function newPrompt(){
  if(!NOUN_GROUPS.length){ promptText.textContent='Upload your noun list (CSV) to start'; return; }
  const nounIdx=Math.floor(Math.random()*NOUN_GROUPS.length);
  const chosen=NOUN_GROUPS[nounIdx];
  const owners=[...new Set(ADJECTIVES_RAW.map(a=>a.owner))];
  const owner=owners[Math.floor(Math.random()*owners.length)];
  window.promptState={ owner, targetNounIndex: nounIdx, nounEnglish: chosen.english };
  promptText.textContent=`${owner.replace('-pl',' (you all)')} ${chosen.english}`;
  resultLine.textContent='‚Äî';
  explain.textContent='Spin both reels to match the prompt, then press ‚ÄúCheck‚Äù.';
}

function check(){
  const st = window.promptState; if(!st){ explain.textContent='Create a prompt first.'; return; }
  const a=currentAdj(), n=currentNoun(), target=NOUN_GROUPS[st.targetNounIndex];

  const ownerOK  = (a.owner===st.owner);
  const agreeOK  = a.variants.some(av => n.variants.some(nv => av.gender===nv.gender && av.number===nv.number));
  const nounOK   = (n.noun===target.noun);
  const allOK    = ownerOK && agreeOK && nounOK;

  resultLine.textContent=allOK?'‚úÖ Correct!':'‚ùå Not quite';

  if (showHints){
    const adjFeat = a.variants.map(v => featAbbrev(v.gender, v.number)).join(', ');
    const nounFeat = n.variants.map(v => featAbbrev(v.gender, v.number)).join(', ');
    const parts=[];
    parts.push(`Prompt: ${st.owner} + ‚Äú${target.english}‚Äù`);
    parts.push(`You chose adj: ‚Äú${a.form}‚Äù (${ownerLabel(a.owner)} ${adjFeat})`);
    parts.push(`and noun: ‚Äú${n.noun}‚Äù (${String(n.english).toUpperCase()} ${nounFeat}).`);
    explain.textContent = parts.join(' ');
  } else {
    explain.textContent = allOK ? '' : 'Try again.';
  }
}

/* ---------- Build ---------- */
function buildAll(){
  buildReel(adjTrack, ADJ_GROUPS, a=>a.form);
  buildReel(nounTrack, NOUN_GROUPS, n=>n.noun);
  adjPos = 2*adjLen + mod(adjPos, adjLen);
  nounPos = 2*nounLen + mod(nounPos, nounLen);
  requestAnimationFrame(()=>{
    adjPos  = renderByPos(adjTrack, adjLen, adjPos);
    nounPos = renderByPos(nounTrack, nounLen, nounPos);
    updateBadges();
  });
}

/* ---------- Events & Inputs ---------- */
buttons.newPromptBtn.addEventListener('click', newPrompt);
buttons.checkBtn.addEventListener('click', check);
btnShowHints.addEventListener('click', ()=>{ showHints=!showHints; updateBadges(); });
buttons.adjPrev.addEventListener('click', ()=>stepAdj(-1));
buttons.adjNext.addEventListener('click', ()=>stepAdj(+1));
buttons.nounPrev.addEventListener('click', ()=>stepNoun(-1));
buttons.nounNext.addEventListener('click', ()=>stepNoun(+1));
adjReel.addEventListener('wheel', wheelHandlerFactory('adj'), {passive:false});
nounReel.addEventListener('wheel', wheelHandlerFactory('noun'), {passive:false});
const adjTouch = touchHandlerFactory('adj'); const nounTouch = touchHandlerFactory('noun');
adjReel.addEventListener('touchstart', adjTouch.start, {passive:true});
adjReel.addEventListener('touchmove', adjTouch.move, {passive:false});
adjReel.addEventListener('touchend', adjTouch.end, {passive:true});
nounReel.addEventListener('touchstart', nounTouch.start, {passive:true});
nounReel.addEventListener('touchmove', nounTouch.move, {passive:false});
nounReel.addEventListener('touchend', nounTouch.end, {passive:true});
adjReel.addEventListener('keydown', keyHandlerFactory('adj'));
nounReel.addEventListener('keydown', keyHandlerFactory('noun'));

/* ---------- CSV upload with smart decoding + conflict handling + encoding label ---------- */
buttons.fileInput.addEventListener('change', async (e)=>{
  const file=e.target.files?.[0]; if(!file) return;
  fileNameEl.textContent=file.name; csvWarn.classList.remove('show'); encodingLabel.textContent='';

  const res = await readFileAsTextSmart(file, ['utf-8','windows-1250','iso-8859-2']);
  const text = res.text; if (res.enc) encodingLabel.textContent = `Encoding detected: ${res.enc.toUpperCase()}`;

  const rows=parseCSV(text);
  const header=rows.shift()||[];
  const idxN=header.findIndex(h=>h.trim().toLowerCase()==='noun');
  const idxG=header.findIndex(h=>h.trim().toLowerCase()==='gender');
  const idxU=header.findIndex(h=>h.trim().toLowerCase()==='number');
  const idxE=header.findIndex(h=>h.trim().toLowerCase()==='english');
  const parsed=[];
  for(const r of rows){
    if(!r.length) continue;
    const noun=r[idxN]?.trim();
    const gender=(r[idxG]||'').trim().toLowerCase();
    const number=(r[idxU]||'').trim().toLowerCase();
    const english=(r[idxE]||'').trim();
    if(noun && ['m','f','n'].includes(gender) && ['sg','pl'/*,'du'*/].includes(number) && english){
      parsed.push({ noun, gender, number, english });
    }
  }

  // Heuristic: if many nouns contain '?' and there are no Slovene diacritics in the raw text, warn the user.
  const replacedCount = parsed.filter(x => x.noun.includes('?')).length;
  const hasDiacritics = /[ƒç≈°≈æƒå≈†≈Ω]/.test(text);
  if (parsed.length && replacedCount >= 2 && !hasDiacritics){
    csvWarn.classList.add('show');
  }

  // group nouns (enforce english consistency)
  NOUN_GROUPS = groupNouns(parsed);
  nounLen = NOUN_GROUPS.length;
  nounPos = 2*nounLen + 0;
  buildAll();
});

/* Heuristic decoder: pick the encoding with the fewest replacement chars (\uFFFD); prefer ones that keep ƒç/≈°/≈æ */
async function readFileAsTextSmart(file, encodings=['utf-8']){
  const buf = await file.arrayBuffer();
  const bytes = new Uint8Array(buf);
  let best = {text:'', score:Infinity, hasDiacritics:false, enc:''};
  const dia = /[ƒç≈°≈æƒå≈†≈Ω]/;
  for(const enc of encodings){
    try{
      const dec = new TextDecoder(enc, {fatal:false});
      const text = dec.decode(bytes);
      const replacements = (text.match(/\uFFFD/g)||[]).length;
      const hasDia = dia.test(text);
      const score = replacements;
      if (score < best.score || (score===best.score && hasDia && !best.hasDiacritics)){
        best = {text, score, hasDiacritics:hasDia, enc};
      }
    }catch{ /* ignore unsupported encoding */ }
  }
  if (!best.text){
    const fallback = new TextDecoder().decode(bytes);
    best = {text:fallback, enc:'utf-8', score:0, hasDiacritics:dia.test(fallback)};
  }
  return best;
}

/* Tiny CSV parser */
function parseCSV(text){
  const out=[]; let row=[], val='', inQ=false;
  for(let i=0;i<text.length;i++){
    const c=text[i], n=text[i+1];
    if(c==='"'){ if(inQ&&n==='"'){ val+='"'; i++; } else inQ=!inQ; }
    else if(c===','&&!inQ){ row.push(val); val=''; }
    else if((c=== '\n' || c=== '\r') && !inQ){
      if(val.length||row.length){ row.push(val); out.push(row); row=[]; val=''; }
      if(c=== '\r' && n=== '\n') i++;
    } else { val+=c; }
  }
  if(val.length||row.length){ row.push(val); out.push(row); }
  return out;
}

/* Init */
let ADJ_GROUPS_INIT = groupAdjectives(ADJECTIVES_RAW); // ensure grouping from start
ADJ_GROUPS = shuffle(ADJ_GROUPS_INIT);
buildAll();

/* PWA: service worker registration */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('service-worker.js')
      .then(reg => console.log('[SW] registered', reg.scope))
      .catch(err => console.warn('[SW] registration failed', err));
  });
}
</script>
</body>
</html>
